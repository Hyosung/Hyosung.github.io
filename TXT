//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
            
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
    
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
    

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        @"processed": [self propertyForKey:protocolKey inRequest:request] ?: @"0"
    };
    NSLog(@"+[%@ canInitWithRequest] \n%@", NSStringFromClass(self), attributeds);
#endif
    return flag;
}

+ (BOOL)isHttpOrHttpsScheme:(NSURLRequest *)request {
    NSURL *url = request.URL;
    NSString *scheme = url.scheme.lowercaseString;
    return [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"https"];
}

/**
 * 如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行
 */
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}

/**
 * 开始加载，在该方法中，加载一个请求
 */
- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];
    // 表示该请求已经被处理，防止无限循环
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    _oriRequestURL = self.request.URL;
    self.curRequest = [self applyHttpDnsIpDirectConnect:request];
    [self startRequest];
}

- (NSString *)cookieForURL:(NSURL *)URL {
    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
    NSMutableArray *cookieList = [NSMutableArray array];
    for (NSHTTPCookie *cookie in [cookieStorage cookies]) {
        if (![self p_checkCookie:cookie URL:URL]) {
            continue;
        }
        [cookieList addObject:cookie];
    }
    
    if (cookieList.count > 0) {
        NSDictionary *cookieDic = [NSHTTPCookie requestHeaderFieldsWithCookies:cookieList];
        if ([cookieDic objectForKey:@"Cookie"]) {
            return cookieDic[@"Cookie"];
        }
    }
    return nil;
}


- (BOOL)p_checkCookie:(NSHTTPCookie *)cookie URL:(NSURL *)URL {
    if (cookie.domain.length <= 0 || URL.host.length <= 0) {
        return NO;
    }
    if ([URL.host containsString:cookie.domain]) {
        return YES;
    }
    return NO;
}

- (NSMutableURLRequest*)applyHttpDnsIpDirectConnect:(NSURLRequest*)request {
    NSURL* originUrl = request.URL;
    NSString* originHost = originUrl.host;
    NSString *cookie = [self cookieForURL:originUrl];
    NSURL* newUrl = [self getIpAndReplace:[originUrl absoluteString]];
    
    NSMutableURLRequest* mutableRequest = [request mutableCopy];
    if (newUrl) {
        mutableRequest.URL = newUrl;
        [mutableRequest setValue:originHost forHTTPHeaderField:@"host"];
    }
    [mutableRequest setValue:cookie forHTTPHeaderField:@"Cookie"];
    
    return mutableRequest;
}

- (NSURL*)getIpAndReplace:(NSString*)urlString {
    NSURL* url = [NSURL URLWithString:urlString];
    NSString* originHost = url.host;
    
    NSArray* result = [[MSDKDns sharedInstance] WGGetHostByName:url.host];
    NSString* ip = nil;
    if (result && result.count > 1) {
        if (![result[0] isEqualToString:@"0"]) {
            ip = result[0];
        } else if (![result[1] isEqualToString:@"0"]) {
            ip = result[1];
        }
    }
    // 通过HTTPDNS获取IP成功，进行URL替换和HOST头设置
    if (originHost.length > 0 && ip.length > 0) {
        NSString* originUrlStringafterdispatch = [url absoluteString];
        NSRange hostRange = [originUrlStringafterdispatch rangeOfString:url.host];
        NSString* urlString = [originUrlStringafterdispatch stringByReplacingCharactersInRange:hostRange withString:ip];
        url = [NSURL URLWithString:urlString];
    } else {
        // 未替换成功
        [WBAnalyticsObjectKit onLogWithCode:@"dns_get_ip_error"
                                 attributes:@{
            @"url": NilString(urlString),
            @"host": NilString(url.host),
            @"result": result ?: @[]
        }];
    }
    return url;
}

/**
 * 取消请求
 */
- (void)stopLoading {
    if (_inputStream.streamStatus == NSStreamStatusOpen || !_inputStream) {
        if (_inputStream) {
            [self closeStream:_inputStream];
        }
        NSError *error = [[NSError alloc] initWithDomain:@"stop loading" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
    }
}

/**
 * 使用CFHTTPMessage转发请求
 */
- (void)startRequest {
#if DEBUG
    if (self.retryCount > 0) {
        NSLog(@"%@ 开始重试(%ld)", _curRequest, self.retryCount);
    }
#endif
    // 原请求的header信息
    NSDictionary *headFields = _curRequest.allHTTPHeaderFields;
    CFURLRef requestURL = (__bridge_retained CFURLRef)_curRequest.URL;
    if (!requestURL) {
        // 进行兜底处理，直接回调失败
        NSError *error = [NSError errorWithDomain:@"Invalid URL" code:-1 userInfo:nil];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        return;
    }
    // 原请求所使用的方法，GET或POST
    CFStringRef requestMethod = (__bridge_retained CFStringRef) _curRequest.HTTPMethod;
    // 根据请求的url、方法、版本创建CFHTTPMessageRef对象
    CFHTTPMessageRef cfrequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, requestURL, kCFHTTPVersion1_1);
    // 添加http post请求所附带的数据
    CFStringRef requestBody = CFSTR("");
    CFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, requestBody, kCFStringEncodingUTF8, 0);
    if (_curRequest.HTTPBody) {
        CFRelease(bodyData);
        bodyData = NULL;
        bodyData = (__bridge_retained CFDataRef) _curRequest.HTTPBody;
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }  else if(_curRequest.HTTPBodyStream) {
        NSData *data = [self dataWithInputStream:_curRequest.HTTPBodyStream];
        if (data) {
            CFDataRef body = (__bridge_retained CFDataRef) data;
            CFHTTPMessageSetBody(cfrequest, body);
            CFRelease(body);
        }
    } else {
        CFHTTPMessageSetBody(cfrequest, bodyData);
    }
    
    // copy原请求的header信息
    for (NSString* header in headFields) {
        CFStringRef requestHeader = (__bridge CFStringRef) header;
        CFStringRef requestHeaderValue = (__bridge CFStringRef) [headFields valueForKey:header];
        CFHTTPMessageSetHeaderFieldValue(cfrequest, requestHeader, requestHeaderValue);
    }
    
    // 创建CFHTTPMessage对象的输入流
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, cfrequest);
    self.inputStream = (__bridge_transfer NSInputStream *) readStream;
    
    // 设置SNI host信息，关键步骤
    NSString *host = [_curRequest.allHTTPHeaderFields objectForKey:@"host"];
    if (!host) {
        host = _curRequest.URL.host;
    }
    
    // https才设置
    if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
        [_inputStream setProperty:NSStreamSocketSecurityLevelNegotiatedSSL forKey:NSStreamSocketSecurityLevelKey];
        NSDictionary *sslProperties = [[NSDictionary alloc] initWithObjectsAndKeys: host, (__bridge id) kCFStreamSSLPeerName, nil];
        [_inputStream setProperty:sslProperties forKey:(__bridge_transfer NSString *) kCFStreamPropertySSLSettings];
    }
    [_inputStream setDelegate:self];
    
    if (!_curRunLoop) {
        // 保存当前线程的runloop，这对于重定向的请求很关键
        self.curRunLoop = [NSRunLoop currentRunLoop];
    }
    // 将请求放入当前runloop的事件队列
    [_inputStream scheduleInRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
    [_inputStream open];
    
    CFRelease(cfrequest);
    if (requestURL) {
        CFRelease(requestURL);
    }
    cfrequest = NULL;
    CFRelease(bodyData);
    CFRelease(requestMethod);
}

- (NSData*)dataWithInputStream:(NSInputStream*)stream {
    NSMutableData *data = [NSMutableData data];
    [stream open];
    NSInteger result;
    uint8_t buffer[1024];
    
    while ((result = [stream read:buffer maxLength:1024]) != 0) {
        if (result > 0) {
            // buffer contains result bytes of data to be handled
            [data appendBytes:buffer length:result];
        } else if (result < 0) {
            // The stream had an error. You can get an NSError object using [iStream streamError]
            data = nil;
            break;
        }
    }
    [stream close];
    return data;
}

#pragma mark - NSStreamDelegate
/**
 * input stream 收到header complete后的回调函数
 */
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    if (eventCode == NSStreamEventHasBytesAvailable) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        NSInputStream *inputstream = (NSInputStream *) aStream;
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)inputstream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) { // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
            // 获取响应头部的状态码
            CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                // 验证证书
                // https才验证证书
                SecTrustResultType res = kSecTrustResultInvalid;
                if ([self.curRequest.URL.absoluteString rangeOfString:@"^https" options:NSRegularExpressionSearch].location != NSNotFound) {
                    SecTrustRef trust = (__bridge SecTrustRef) [aStream propertyForKey:(__bridge NSString *) kCFStreamPropertySSLPeerTrust];
                    NSMutableArray *policies = [NSMutableArray array];
                    NSString *domain = [[_curRequest allHTTPHeaderFields] valueForKey:@"host"];
                    if (domain) {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateSSL(true, (__bridge CFStringRef) domain))];
                    } else {
                        [policies addObject:CFBridgingRelease(SecPolicyCreateBasicX509())];
                    }
                    /*
                     * 绑定校验策略到服务端的证书上
                     */
                    SecTrustSetPolicies(trust, (__bridge CFArrayRef) policies);
                    if (SecTrustEvaluate(trust, &res) != errSecSuccess) {
                        [self closeStream:aStream];
                        NSError *error = [[NSError alloc] initWithDomain:@"can not evaluate the server trust" code:-1 userInfo:nil];
                        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        CFRelease(message);
                        return;
                    }
                } else {
                    res = kSecTrustResultProceed;
                }
                if (res != kSecTrustResultProceed && res != kSecTrustResultUnspecified) {
                    /* 证书验证不通过，关闭input stream */
                    [self closeStream:aStream];
                    NSError *error = [[NSError alloc] initWithDomain:@"fail to evaluate the server trust" code:-1 userInfo:nil];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    // 证书校验通过
                    if (statusCode >= 300 && statusCode < 400) {
                        // 处理重定向错误码
                        [self closeStream:aStream];
                        [self handleRedirect:headDict statusCode:statusCode];
                    } else {
                        // 返回成功收到的数据
                        NSError *error = nil;
                        NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                        if (error) {
                            [self closeStream:aStream];
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                        } else {
                            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                        }
                    }
                }
            } else {
                // 证书已验证过，返回数据
                NSError *error = nil;
                NSData *data = [self readDataFromInputStream:inputstream headerDict:headDict statusCode:statusCode error:&error];
                if (error) {
                    [self closeStream:aStream];
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
                } else {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidLoadData object:data];
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
    } else if (eventCode == NSStreamEventErrorOccurred) {
        [self closeStream:aStream];
        NSError *error = aStream.streamError ?: [[NSError alloc] initWithDomain:@"NSStreamEventErrorOccurred" code:-1 userInfo:nil];
        
        if (self.retryCount < self.maxRetryCount) {
            self.retryCount++;
            
            #if DEBUG
                NSLog(@"stream:handleEvent:(%ld) \n%@", self.retryCount, error);
            #endif
            
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description),
                @"retryCount": @(self.retryCount)
            };
            
            [WBAnalyticsObjectKit onLogWithCode:@"dns_retry"
                                     attributes:attributes];
                                      
            // 再次发起请求
            [self performSelector:@selector(startRequest) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];
        } else {
            // 通知client发生错误了
            [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFail object:error];
        }
    } else if (eventCode == NSStreamEventEndEncountered) {
        if (![aStream isKindOfClass:NSInputStream.class]) {
            return;
        }
        CFReadStreamRef readStream = (__bridge CFReadStreamRef)(NSInputStream *)aStream;
        CFHTTPMessageRef message = (CFHTTPMessageRef) CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
        if (message && CFHTTPMessageIsHeaderComplete(message)) {
            // 以防response的header信息不完整
            NSNumber *alreadyAdded = objc_getAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded));
            if (!alreadyAdded || ![alreadyAdded boolValue]) {
                objc_setAssociatedObject(aStream, (__bridge const void *)(kAnchorAlreadyAdded), [NSNumber numberWithBool:YES], OBJC_ASSOCIATION_COPY);
                // 通知client已收到response，只通知一次
                NSDictionary *headDict = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(message));
                NSString *httpVersion = CFBridgingRelease(CFHTTPMessageCopyVersion(message));
                // 获取响应头部的状态码
                CFIndex statusCode = CFHTTPMessageGetResponseStatusCode(message);
                NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:self.oriRequestURL
                                                                          statusCode:statusCode
                                                                         HTTPVersion:httpVersion
                                                                        headerFields:headDict];
                                                                        
                // Location有值，并且statusCode为3xx
                BOOL isValidRedirect = [self locationHeaderFromResponse:headDict].length && (statusCode >= 300 && statusCode < 400);
                // 重定向时，不返回重定向的Response，成功后才返回
                if (!isValidRedirect) {
                    [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidReceiveResponse object:response];
                }
                
                if (statusCode >= 300 && statusCode < 400) {
                    // 处理重定向错误码; 重定向时后续逻辑不走
                    [self closeStream:aStream];
                    [self handleRedirect:headDict statusCode:statusCode];
                    CFRelease(message);
                    return;
                }
            }
        }
        if (message) {
            CFRelease(message);
        }
        [self closeStream:_inputStream];
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
    }
}

- (void)closeStream:(NSStream*)stream {
    if (stream) {
        if (_curRunLoop) {
            [stream removeFromRunLoop:_curRunLoop forMode:NSRunLoopCommonModes];
        }
        [stream setDelegate:nil];
        if (stream.streamStatus != NSStreamStatusClosed) {
            [stream close];
        }
    }
    // 再成对地销毁 gzip 流（只做一次）
    if (_gzipStreamInited) {
        inflateEnd(&_gzipStream);
        _gzipStreamInited = NO;
    }
}

- (void)handleRedirect:(NSDictionary *)headDict statusCode:(NSInteger)statusCode {
    // 重定向时如果有cookie需求的话，注意处理
    NSString *location = [self locationHeaderFromResponse:headDict];
    if (!location.length) {
        [self clientCallbackWithType:ZMURLProtocolClientCallbackTypeDidFinishLoading object:nil];
        return;
    }
    
    NSURL *url;
    if ([location rangeOfString:@"^https?://" options:NSRegularExpressionSearch].location != NSNotFound) {
        // 绝对路径
        url = [NSURL URLWithString:location];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]];
        }
    } else {
        // 相对路径
        url = [NSURL URLWithString:location relativeToURL:self.oriRequestURL];
        if (!url) {
            // 兜底处理
            url = [NSURL URLWithString:[location stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet] relativeToURL:self.oriRequestURL];
        }
        url = url.absoluteURL;
    }
    // scheme://[user[:password]@host[:port]][/path][?query][#fragment]
    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];
    if (!urlComponents.query.length && self.oriRequestURL.query.length) {
        urlComponents.query = self.oriRequestURL.query;
    }
    if (!urlComponents.fragment.length && self.oriRequestURL.fragment.length) {
        urlComponents.fragment = self.oriRequestURL.fragment;
    }
    
    NSURL *recombinedURL = urlComponents.URL;
    
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 从哪个url重定向过来的
        @"originURL": NilString(url.absoluteString), // 替换ip前的url，未追加query和fragment
        @"recombinedURL": NilString(recombinedURL.absoluteString), // 替换ip前的url，已追加query和fragment
        @"statusCode": @(statusCode), // 状态码
        @"location": NilString(location), // 重定向到哪里
    } mutableCopy];
    
    if (recombinedURL) {
        url = recombinedURL;
    }
    
    _curRequest.URL = url;
    _oriRequestURL = url;
    // 303 总是使用GET请求
    if (statusCode == 303) {
        _curRequest.HTTPMethod = @"GET";
        _curRequest.HTTPBody = nil;
    }
    
    NSURL *newUrl = [self getIpAndReplace:[url absoluteString]];
    if (newUrl) {
        _curRequest.URL = newUrl;
        attributes[@"newURL"] = NilString(newUrl.absoluteString); // 替换ip后的url
        [_curRequest setValue:url.host forHTTPHeaderField:@"host"];
    }
    [self startRequest];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_redirect_info"
                             attributes:attributes];
}

- (NSString *)locationHeaderFromResponse:(NSDictionary *)headers {
    return headers[@"Location"] ?: headers[@"location"];
}

- (NSData *)readDataFromInputStream:(NSInputStream *)inputStream
                         headerDict:(NSDictionary *)headDict
                         statusCode:(NSInteger)statusCode
                              error:(NSError **)error {
    NSMutableDictionary *attributes = [@{
        @"fromURL": NilString(self.oriRequestURL.absoluteString), // 来源URL，使用域名请求的
        @"URL": NilString(self.curRequest.URL.absoluteString), // 替换ip后的URL,使用ip请求的
        @"statusCode": @(statusCode), // 状态码
        @"responseHeaders": headDict ?: @{} // 响应头信息
    } mutableCopy];
    
    [WBAnalyticsObjectKit onLogWithCode:@"dns_response_info"
                             attributes:attributes];
                              
    UInt8 buffer[16 * 1024];
    
    NSInteger length = [inputStream read:buffer maxLength:sizeof(buffer)];
    if (length < 0) {
        *error = inputStream.streamError ?: [[NSError alloc] initWithDomain:@"inputstream length is invalid"
                                                                       code:-2
                                                                   userInfo:nil];
        return nil;
    }
    
    NSData *data = [[NSData alloc] initWithBytes:buffer length:length];
    NSString *contentEncoding = headDict[@"Content-Encoding"];
    // 检测服务器响应头里是不是 gzip
    if (contentEncoding && [contentEncoding.lowercaseString containsString:@"gzip"]) {
        if (![self initializeGzipstream:error]) {
            return nil;
        }
        
        data = [self gzipUncompress:data error:error];
    }
    
    return data;
}

- (BOOL)initializeGzipstream:(NSError **)error {
    if (!_gzipStreamInited) {
        // 第一次请求，初始化解压上下文
        memset(&_gzipStream, 0, sizeof(_gzipStream));
        int ret = inflateInit2(&_gzipStream, 16 + MAX_WBITS);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateInit2 failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip initialize fail" code:ret userInfo:nil];
            return NO;
        } else {
            _gzipStreamInited = YES;
            return YES;
        }
    } else {
        // 重用同一个实例发起新请求时，重置解压上下文
        int ret = inflateReset(&_gzipStream);
        if (ret != Z_OK) {
            NSLog(@"⚠️ gzip inflateReset failed: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip reset fail" code:ret userInfo:nil];
            return NO;
        } else {
            return YES;
        }
    }
}

- (NSData *)gzipUncompress:(NSData *)compressedData error:(NSError **)error {
    // 保证只有在 _gzipStreamInited == YES 时才用 _gzipStream
    if (!_gzipStreamInited || compressedData.length <= 0) return compressedData;
    
    NSMutableData *outData = [NSMutableData data];
    _gzipStream.next_in   = (Bytef *)compressedData.bytes;
    _gzipStream.avail_in  = (uInt)compressedData.length;
    Bytef buffer[1024];
    
    while (_gzipStream.avail_in > 0) {
        _gzipStream.next_out  = buffer;
        _gzipStream.avail_out = sizeof(buffer);
        int ret = inflate(&_gzipStream, Z_NO_FLUSH);
        if (ret == Z_STREAM_END || ret == Z_OK) {
            NSUInteger have = sizeof(buffer) - _gzipStream.avail_out;
            [outData appendBytes:buffer length:have];
            if (ret == Z_STREAM_END) break;
        } else {
            NSLog(@"⚠️ gzip inflate error: %d", ret);
            *error = [[NSError alloc] initWithDomain:@"gzip inflate error" code:ret userInfo:nil];
            break;
        }
    }
    return [NSData dataWithData:outData];
}

@end

//
//  ZMDnsHttpMessageTools.m
//  ZMClient
//
//  Created by stone.y on 2025/2/8.
//  Copyright © 2025 Perch Communications. All rights reserved.
//

#import "ZMDnsHttpMessageTools.h"
#import <Foundation/Foundation.h>
#import <arpa/inet.h>
#import <objc/runtime.h>
#import <MSDKDns/MSDKDns.h>
#import <MSDKDns/MSDKDnsHttpMessageTools.h>
#import "ZMHTTPDNSManager.h"
#import <ZMWindVane/ZMWVDefine.h>
#import <zlib.h>

typedef NS_ENUM(NSUInteger, ZMURLProtocolClientCallbackType) {
    ZMURLProtocolClientCallbackTypeDidReceiveResponse,
    ZMURLProtocolClientCallbackTypeDidLoadData,
    ZMURLProtocolClientCallbackTypeDidFinishLoading,
    ZMURLProtocolClientCallbackTypeDidFail,
};

static NSString *const protocolKey = @"MSDKDnsHttpMessagePropertyKey";
static NSString *const kAnchorAlreadyAdded = @"AnchorAlreadyAdded";

@interface ZMDnsHttpMessageTools () <NSStreamDelegate>

@property (strong, readwrite, nonatomic) NSMutableURLRequest *curRequest;
@property (strong, readwrite, nonatomic) NSURL *oriRequestURL; // 未改ip前的request url
@property (strong, readwrite, nonatomic) NSRunLoop *curRunLoop;
@property (strong, readwrite, nonatomic) NSInputStream *inputStream;
@property (assign, nonatomic) z_stream gzipStream;
@property (assign, nonatomic) BOOL gzipStreamInited;

/// 当前已经重试的次数
@property (nonatomic, assign) NSInteger retryCount;
/// 最大重试次数，默认 3 次
@property (nonatomic, assign) NSInteger maxRetryCount;
@end

@implementation ZMDnsHttpMessageTools

- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id<NSURLProtocolClient>)client {
    self = [super initWithRequest:request cachedResponse:cachedResponse client:client];
    if (self) {
        _gzipStreamInited = NO;
        _retryCount = 0;
        _maxRetryCount = ZMHTTPDNSManager.sharedManager.maxRetryCount;
    }
    return self;
}

- (void)clientCallbackWithType:(ZMURLProtocolClientCallbackType)type object:(id)object {
    switch (type) {
        case ZMURLProtocolClientCallbackTypeDidFinishLoading: {
            self.retryCount = 0;
            [self.client URLProtocolDidFinishLoading:self];
#if DEBUG
            NSDictionary *attributeds = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                }
            };
            NSLog(@"URLProtocolDidFinishLoading: \n%@", attributeds);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidLoadData: {
            NSData *data;
            if ([object isKindOfClass:NSData.class]) {
                data = object;
            } else {
                data = [NSData data];
            }
            [self.client URLProtocol:self didLoadData:data];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"data": data
            //            };
            //            NSLog(@"URLProtocol:didLoadData: \n%@", attributeds);
            //#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidFail: {
            self.retryCount = 0;
            NSError *error = ([object isKindOfClass:NSError.class] ? object :
                              [[NSError alloc] initWithDomain:@"custom error" code:-1 userInfo:nil]);
            // 重试用尽，真正通知失败
            [self.client URLProtocol:self didFailWithError:error];
            NSDictionary *attributes = @{
                @"origin": @{
                    @"url": NilString(self.request.URL.absoluteString),
                    @"method": NilString(self.request.HTTPMethod),
                    @"headers": self.request.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.request.HTTPBody ? YES : NO)
                },
                @"new": @{
                    @"url": NilString(self.curRequest.URL.absoluteString),
                    @"method": NilString(self.curRequest.HTTPMethod),
                    @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
                    @"hasBody": @(self.curRequest.HTTPBody ? YES : NO)
                },
                @"error": NilString(error.description)
            };
            [WBAnalyticsObjectKit onLogWithCode:@"dns_load_error"
                                     attributes:attributes];
#if DEBUG
            NSLog(@"URLProtocol:didFailWithError: \n%@", attributes);
#endif
            break;
        }
        case ZMURLProtocolClientCallbackTypeDidReceiveResponse: {
            // 收到新 response，视为请求成功开始
            self.retryCount = 0;
            if (![object isKindOfClass:NSURLResponse.class]) {
                return;
            }
            [self.client URLProtocol:self didReceiveResponse:object cacheStoragePolicy:NSURLCacheStorageNotAllowed];
            //#if DEBUG
            //            NSDictionary *attributeds = @{
            //                @"url": NilString(self.curRequest.URL.absoluteString),
            //                @"method": NilString(self.curRequest.HTTPMethod),
            //                @"headers": self.curRequest.allHTTPHeaderFields ?: @{},
            //                @"hasBody": @(self.curRequest.HTTPBody ? YES : NO),
            //                @"response": object
            //            };
            //            NSLog(@"URLProtocol:didReceiveResponse:cacheStoragePolicy: \n%@", attributeds);
            //#endif
            break;
        }
    }
}

- (NSURL *)oriRequestURL {
    if (!_oriRequestURL) {
        _oriRequestURL = self.request.URL;
    }
    return _oriRequestURL;
}

/**
 *  是否拦截处理指定的请求
 *
 *  @param request 指定的请求
 *
 *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理
 */
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    // 1.开关打开
    // 2.scheme为http/https
    // 3.host不是特殊的
    // 4.不是待处理的web post请求
    // 5.在黑名单中匹配不到
    // 6.腾讯的相关判断逻辑
    BOOL flag = ZMHTTPDNSManager.sharedManager.isOpened
    && [self isHttpOrHttpsScheme:request]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchLocalBlacklistForRequest:request]
    && ![request.URL.absoluteString containsString:kZMWVXMLHttpRequestId]
    && ![ZMHTTPDNSManager.sharedManager doesHostMatchBlacklistForRequest:request]
    && [MSDKDnsHttpMessageTools canInitWithRequest:request];
#if DEBUG
    NSDictionary *attributeds = @{
        @"url": NilString(request.URL.absoluteString),
        @"method": NilString(request.HTTPMethod),
        @"headers": request.allHTTPHeaderFields ?: @{},
        @"hasBody": @(request.HTTPBody ? YES : NO),
        @"canInit": @(flag),
        
    
